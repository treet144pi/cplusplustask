#include <iostream>
#include <algorithm> // для алгоритмов
#include <vector>
using namespace std;

bool compare(const float a,const float b) // функция по убывания тк по умолчанию  по возрастанию
{
    return (a>b) ? true : false;
}
int main()
{
    float ar[5] = {1.222,6.3332,10.221,2223.222,100000.222};
    vector<float> arr(ar,ar+5); //
    // sort(arr,arr+5); // ставим начальный индекс символ массив и на указатель после послденего элемента
    sort(arr.begin(),arr.end(),compare); // по убывания итераторы
    for (int i=0;i<5;i++)
        cout<<arr[i]<<endl;


    return 0;
}
/*Методы swap(), empty(), back() и pop_back()
Следующий пример, VECTCON, демонстрирует еще несколько методов и векторов.
Листинг 15.12. Программа VECTCON
// vectcon.cpp
// демонстрация конструкторов, swap(), empty(), back(), pop_back()
#include <iostream>
#include <vector>
using namespace std;
int main()
{
 double arr[] = { 1.1, 2.2, 3.3, 4.4 }; // массив типа double
 vector<double> v1(arr, arr + 4); // инициализация вектора
 // массивом
 vector<double> v2(4); // пустой вектор. Размер = 4
 v1.swap(v2); // обменять содержимое v1 и v2
 while(!v2.empty()) // пока вектор не будет пуст,
 {
 cout << v2.back() << ' '; // вывести последний элемент
 v2.pop_back(); // и удалить его
 } // вывод: 4.4 3.3 2.2 1.1
 cout << endl;
 return 0;
}
В этой программе мы использовали два новых конструктора векторов. Первый инициализирует вектор v1 значениями обычного массива C++, переданного
ему в качестве аргумента. Аргументами этого конструктора являются указатели
на начало массива и на элемент «после последнего». Во втором конструкторе
вектор v2 инициализируется установкой его размера. Мы положили его равным 4. Но значение самого вектора при инициализации не передается. Оба вектора содержат данные типа double.
Метод swap() обменивает данные одного вектора на данные другого, при этом
порядок следования элементов не изменяется. В этой программе в векторе v2
содержится только мусор какой-то, а данных не содержится, поэтому он обменивается на вектор vl. Результат работы программы таков:
4.4. 3.3. 2.2. 1.1
Метод back() возвращает значение последнего элемента вектора. Мы выводим его с помощью cout. Метод pop_back() удаляет последний элемент вектора.
Таким образом, при каждом прохождении цикла последний элемент будет
иметь разные значения. (Немного удивительно, что pop_back() только удаляет
последний элемент, но не возвращает его значение, как pop() при работе со стеком. Поэтому, в принципе, всегда нужно использовать pop_back() и back() в паре.)
Некоторые методы, например swap(), существуют и в виде алгоритмов. В таких
случаях лучше предпочесть метод алгоритму. Работа с методом для конкретного
контейнера обычно оказывается более эффективной. Иногда имеет смысл использовать и то, и другое. Например, такой подход можно использовать для обмена элементов двух контейнеров разных типов*/
